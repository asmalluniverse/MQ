```shell
1. AMQP 中的消息路由
Exchange 类型
Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、
headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器
完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：

	1.direct:消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队
	列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing
	key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的
	模式。

	2fanout
	每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是
	简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。
	很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。

	3.topic
	topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到
	一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个
	通配符：符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.*” 只会匹配到“audit.irs”

2.redis集群模式
rabbitmq有三种模式：单机模式，普通集群模式，镜像集群模式

	普通集群（只有一个节点保存数据以及元数据信息，其他节点只保存元数据信息，并不能达到所谓的高可用，鸡肋）
	将 RabbitMQ 部署到多台服务器上，每个服务器启动一个 RabbitMQ 实例，多个实例之间进行消息通信。
	此时我们创建的队列 Queue，它的元数据（主要就是 Queue 的一些配置信息）会在所有的 RabbitMQ 实例中进行同步，但是队列中的消息只会存在于一个 RabbitMQ 实例上，而不会同步到其他队列。
	当我们消费消息的时候，如果连接到了另外一个实例，那么那个实例会通过元数据定位到 Queue 所在的位置，然后访问 Queue 所在的实例，拉取数据过来发送给消费者。
	这种集群可以提高 RabbitMQ 的消息吞吐能力，但是无法保证高可用，因为一旦一个 RabbitMQ 实例挂了，消息就没法访问了，如果消息队列做了持久化，那么等 RabbitMQ 实例恢复后，就可以继续访问了；如果消息队列没做持久化，那么消息就丢了。

	镜像集群
	和普通集群最大的区别在于 Queue 数据和原数据不再是单独存储在一台机器上，而是同时存储在多台机器上。也就是说每个 RabbitMQ 实例都有一份镜像数据（副本数据）。每次写入消息的时候都会自动把数据同步到多台实例上去，这样一旦其中一台机器发生故障，其他机器还有一份副本数据可以继续提供服务，也就实现了高可用。

	镜像集群模式
	好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。
	坏处在于

	第一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！
	第二，这么玩儿，就没有扩展性可言了，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue

3.死信队列
死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，
可以被重新发送到另一个交换机，这个交换机就是DLX
	消息成为死信的三种情况：
	1. 队列消息长度到达限制；
	2. 消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队
	列,requeue=false；
	3. 原队列存在消息过期设置，消息到达超时时间未被消费；
	
4.TTL
Time To Live，消息过期时间设置，声明队列时，指定即可
TTL:过期时间
	1. 队列统一过期
	2. 消息单独过期
	如果设置了消息的过期时间，也设置了队列的过期时间，它以时间短的为准。
	队列过期后，会将队列所有消息全部移除
	消息过期后，只有消息在队列顶端，才会判断其是否过期(移除掉)
```
